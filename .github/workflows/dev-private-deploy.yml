name: Dev Private Deploy

on:
  push:
    branches-ignore:
      - 'gh-pages'  # 忽略非代码分支

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 方案更新：显式信任自签名证书，解决 Docker 协议协商问题
      - name: Trust Self-Signed Certificate
        run: |
          # 获取服务器证书
          echo "Fetching certificate from topren.top:5000..."
          echo -n | openssl s_client -showcerts -connect topren.top:5000 2>/dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > custom-registry.crt

          # 验证证书内容是否获取成功
          if [ ! -s custom-registry.crt ]; then
            echo "Failed to fetch certificate!"
            exit 1
          fi

          # 安装证书到系统信任库
          sudo cp custom-registry.crt /usr/local/share/ca-certificates/custom-registry.crt
          sudo update-ca-certificates

          # 关键修改：不再配置 insecure-registries
          # 因为证书已被信任，Docker 应将其视为正常的 HTTPS 仓库
          # 之前配置 insecure-registries 反而导致 Docker 优先尝试 HTTP (400)

          # 重启 Docker 确保加载新的 CA 证书
          sudo systemctl restart docker
          while ! docker info > /dev/null 2>&1; do echo "Waiting for Docker to start..."; sleep 1; done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
          # BuildKit 容器内可能没有宿主机的 CA 证书，所以这里允许 insecure 以确保 push 成功
          config-inline: |
            [registry."topren.top:5000"]
              insecure = true

      - name: Log in to Private Registry (Manual)
        env:
          REGISTRY_USER: ${{ secrets.PRIVATE_REGISTRY_USERNAME }}
          REGISTRY_PWD: ${{ secrets.PRIVATE_REGISTRY_PASSWORD }}
        run: |
          echo "$REGISTRY_PWD" | docker login topren.top:5000 -u "$REGISTRY_USER" --password-stdin

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: topren.top:5000/claude-relay-service
          # 生成两种 tag:
          # 1. 分支名 (例如: dev, fix-bug) - 总是指向该分支最新代码
          # 2. commit hash (例如: sha-7b3f1a2) -用于回溯历史版本
          tags: |
            type=ref,event=branch
            type=sha,format=short,prefix=dev-

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 新增步骤：处理分支名，将 / 替换为 - 以适配 Docker Tag 规范
      - name: Sanitize Branch Name
        id: branch_name
        run: |
          # 获取原始分支名
          RAW_BRANCH="${{ github.ref_name }}"
          # 将 / 替��为 -
          SANITIZED_BRANCH="${RAW_BRANCH//\//-}"
          echo "Original: $RAW_BRANCH"
          echo "Sanitized: $SANITIZED_BRANCH"
          echo "tag=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT

      # 远程执行部署命令
      # 注意：不再上传 docker-compose.yml，避免覆盖服务器的 JWT_SECRET/ENCRYPTION_KEY 配置
      - name: SSH Remote Deploy
        uses: appleboy/ssh-action@master
        env:
          PRIVATE_REGISTRY_USERNAME: ${{ secrets.PRIVATE_REGISTRY_USERNAME }}
          PRIVATE_REGISTRY_PASSWORD: ${{ secrets.PRIVATE_REGISTRY_PASSWORD }}
          # 使用处理后的 Tag
          IMAGE_TAG: ${{ steps.branch_name.outputs.tag }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          password: ${{ secrets.DEPLOY_PASSWORD }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          envs: PRIVATE_REGISTRY_USERNAME,PRIVATE_REGISTRY_PASSWORD,IMAGE_TAG
          script: |
            # 1. 登录私有仓库 (确保服务器也能访问)
            # 注意：如果服务器未配置证书信任，这里可能需要 --tls-verify=false 或者复用 CI 的证书逻辑
            # 为简单起见，这里假设服务器已经配置了 daemon.json 的 insecure-registries 或者信任了证书
            echo "$PRIVATE_REGISTRY_PASSWORD" | docker login topren.top:5000 -u "$PRIVATE_REGISTRY_USERNAME" --password-stdin

            # 2. 进入目录
            cd /root/docker

            # 3. 设���镜像名环境变量
            export DOCKER_IMAGE_NAME="topren.top:5000/claude-relay-service:${IMAGE_TAG}"
            echo "Deploying image: $DOCKER_IMAGE_NAME"

            # 4. 拉取并重启
            # -E 保持环境变量传给 sudo (如果 docker 需要 sudo)
            # 如果是 root 用户直接运行，不需要 sudo
            docker-compose pull
            docker-compose up -d

            # 5. 清理旧镜像 (可选，释放空间)
            docker image prune -f
